// Copyright 2018 The Go Authors. All rights reserved.
// Author: jeremyyin (Dongxun Yin)
package querylog

import (
	"QueryLogBuilder4Go/src/common"
	"github.com/sirupsen/logrus"
	"bytes"
	"strings"
	"sync"
	"strconv"
)

// This class is responsible for aggregating and reporting the timers and counters.
// It is not thread safe.
//
// In order to minimize garbage generated by this class when converting its content to
// a string for logging, it tracks an estimate of its anticipated character representation
// in order to preallocate a string that's an appropriate size.
//
// The estimate isn't perfect (it is an estimate, not a fact). It must never be smaller than
// the needed size; that defeats the point of estimation and would result in reallocation
// of the StringBuilder. It shouldn't be much larger than needed in most cases; but it will
// err to the large size because some things are too cumbersome to estimate and do better as
// a "largest possible size".
//
// Two such examples are numbers and default headers. We might add string representations of
// numbers, and could size them before doing so. That's too cumbersome, so we just use the number
// of characters in long.MIN_VALUE, for example. Default headers are headers that could be in any
// log entry, but might not be there. We know the length of the names, but don't know the length
// of the values; and also don't know presence. Again, we err on the high side (but not
// egregiously so) for this case.
const (
	OPERATION_KEY string = "Operation"
	STATUS_KEY string = "Status"
	QUERY_LOG_STATUS_KEY string = "QueryLogStatus"
)

type EventDataImpl struct {
	timeSource 			querylog.TimeSource
	applicationName 	string
	hostName 			string
	queryLog 			*logrus.Logger
	listeners 			[]QueryLogEntryListener
	defaultNameValues 	map[string]string
	quietMode		 	bool
	remoteAddr 			string
	endTime 			int64
	startTime 			int64
	startEvent 			int64
	eventCount 			int64
	counters 			map[string]int64
	nameValues 			map[string]string
	aggregators 		map[string]*TimerAggregator
	eventHistory 		*EventHistory
	mutex				*sync.Mutex
}

func NewEventDataImpl(
	timeSource querylog.TimeSource,
	applicationName string,
	hostName string,
	defaults map[string]string,
	queryLog *logrus.Logger,
	listeners []QueryLogEntryListener,
	quietMode bool) *EventDataImpl {
	event := EventDataImpl{}

	event.timeSource = timeSource
	event.applicationName = applicationName
	event.hostName = hostName
	event.queryLog = queryLog
	event.listeners = listeners
	event.defaultNameValues = defaults
	event.quietMode = quietMode

	if !quietMode {
		event.eventHistory = NewEventHistory()
	}

	event.aggregators = make(map[string]*TimerAggregator)
	event.nameValues = make(map[string]string)
	event.counters = make(map[string]int64)
	event.mutex = &sync.Mutex{}

	return &event
}

// Implementation of EventData interface
func (event *EventDataImpl) GetApplicationName() string {
	return event.applicationName
}

func (event *EventDataImpl) GetHostName() string {
	return event.hostName
}

func (event *EventDataImpl) GetOperation() string {
	return event.GetValue(OPERATION_KEY)
}

func (event *EventDataImpl) SetOperation(operation string) {
	event.AddNameValuePair(OPERATION_KEY, operation)
}

func (event *EventDataImpl) GetStatus() string {
	return event.GetValue(STATUS_KEY)
}

func (event *EventDataImpl) SetStatus(status string) {
	event.AddNameValuePair(STATUS_KEY, status)
}

func (event *EventDataImpl) GetQueryLogStatus() string {
	return event.GetValue(QUERY_LOG_STATUS_KEY)
}

func (event *EventDataImpl) SetQueryLogStatus(status string) {
	event.AddNameValuePair(QUERY_LOG_STATUS_KEY, status)
}

func (event *EventDataImpl) Reset() {
	event.SetEndTime(0)
	event.SetStartTime(0)
	event.counters = make(map[string]int64)
	event.nameValues = make(map[string]string)
	event.aggregators = make(map[string]*TimerAggregator)

	if event.eventHistory != nil {
		event.eventHistory.Clear()
	}
}

func (event *EventDataImpl) GetStartTime() int64 {
	return event.startTime
}

func (event *EventDataImpl) SetStartTime(startTime int64) {
	event.startTime = startTime
	event.startEvent = startTime
	event.eventCount = 0

	if event.producesHistory() {
		event.eventHistory.Elapsed("start", startTime)
	}
}

func (event *EventDataImpl) GetEndTime() int64 {
	return event.endTime
}

func (event *EventDataImpl) SetEndTime(endTime int64) {
	if event.eventCount > 0 && endTime != event.startEvent {
		event.FinishCurrentEvent("eventSlop")
		event.SetCounter("eventCount", event.eventCount)
	}

	event.endTime = endTime

	if event.producesHistory() {
		event.eventHistory.Elapsed("end", endTime)
	}
}

func (event *EventDataImpl) StartTimer(name string) error {
	agg, contains := event.aggregators[name]

	if !contains {
		agg, err := NewTimerAggregator(name)
		if err != nil {
			return err
		}

		event.aggregators[name] = agg
	}

	now := event.timeSource.CurrentTimeMillis()

	agg, _ = event.aggregators[name]

	agg.Start(now)

	if event.producesHistory() {
		event.eventHistory.Elapsed("s-" + name, now)
	}

	return nil
}

func (event *EventDataImpl) EndTimer(name string) {
	agg, contains := event.aggregators[name]

	if !contains {
		return
	}

	now := event.timeSource.CurrentTimeMillis()

	agg.End(now)

	if event.producesHistory() {
		event.eventHistory.Elapsed("e-" + name, now)
	}
}

func (event *EventDataImpl) UpdateTimer(name string, elapsed int64) error {
	return event.UpdateTimerWithSample(name, elapsed, 1)
}

func (event *EventDataImpl) UpdateTimerWithSample(name string, elapsed, sample int64) error {
	agg, contains := event.aggregators[name]

	if !contains {
		agg, err := NewTimerAggregator(name)

		if err != nil {
			return err
		}

		event.aggregators[name] = agg
	}

	agg, _ = event.aggregators[name]
	agg.AddTimeWithSample(elapsed, sample)

	return nil
}

func (event *EventDataImpl) GetTimeElapsed(timerName string) int64 {
	timer, contains := event.aggregators[timerName]
	if !contains {
		return -1
	}

	return timer.GetTotalElapsed()
}

func (event *EventDataImpl) GetRemoteAddr() string {
	return event.remoteAddr
}

func (event *EventDataImpl) SetRemoteAddr(addr string) {
	event.remoteAddr = addr
}

func (event *EventDataImpl) GetCounter(name string) int64 {
	value, contains := event.counters[name]
	if !contains {
		return 0
	}

	return value
}

func (event *EventDataImpl) SetCounter(name string, value int64) {
	event.counters[name] = value
}

func (event *EventDataImpl) InCCounter(name string, delta int64) {
	oldValue, contains := event.counters[name]

	if !contains {
		oldValue = delta
	} else {
		oldValue += delta
	}

	event.counters[name] = oldValue
}

func (event *EventDataImpl) AddNameValuePair(name, value string) {
	event.nameValues[name] = value
}

func (event *EventDataImpl) AppendNameValuePair(name, value string) {
	existingValue, contains := event.nameValues[name]
	if !contains {
		event.nameValues[name] = value
	} else if len(existingValue) >= MAX_VALUE_SIZE {
		if !strings.HasSuffix(existingValue, COMMA_TRUNCATED_STRING) {
			event.nameValues[name] = existingValue + COMMA_TRUNCATED_STRING
		}
	} else {
		event.nameValues[name] = existingValue + "," + value
	}
}

func (event *EventDataImpl) GetValue(name string) string {
	value, _ := event.nameValues[name]
	return value
}

func (event *EventDataImpl) FinishCurrentEvent(name string) {
	now := event.timeSource.CurrentTimeMillis()

	if event.startEvent == 0 {
		event.startEvent = now
	}

	elapsed := now - event.startEvent
	event.UpdateTimer(name, elapsed)
	event.startEvent = now
	event.eventCount++

	if event.producesHistory() {
		event.eventHistory.Elapsed(name, now)
	}
}

func (event *EventDataImpl) RecordHistoryEvent(name string) {
	if event.producesHistory() {
		event.eventHistory.Elapsed(name, event.timeSource.CurrentTimeMillis())
	}
}

func (event *EventDataImpl) ToJsonFormat() string {
	entry := QueryLogEntryImpl{}
	return entry.FormatAsJson(event)
}

func (event *EventDataImpl) ToEventDataFormat() string {
	return event.toString()
}

// Custom fuction
func (event *EventDataImpl) hasCounters() bool {
	return len(event.counters) > 0
}

func (event *EventDataImpl) appendCounters(builder *bytes.Buffer) {
	var isFirst bool = true

	for k, v := range event.counters {
		if isFirst {
			isFirst = false
		} else {
			builder.WriteByte(',')
		}

		builder.WriteString(k)
		builder.WriteByte('=')
		builder.WriteString(strconv.FormatInt(v, 10))
	}
}

func (event *EventDataImpl) appendTimers(builder *bytes.Buffer) {
	var isFirst bool = true

	for _, v := range event.aggregators {
		if isFirst {
			isFirst = false
		} else {
			builder.WriteByte(',')
		}
		str, _ := v.ToStringWithTimeSource(event.timeSource)
		builder.WriteString(str)
	}
}

func (event *EventDataImpl) addDefaultNameValuePairs() {
	event.mutex.Lock()
	defer event.mutex.Unlock()

	for k, v := range event.defaultNameValues {
		_, contains := event.nameValues[k]
		if contains {
			continue
		}

		event.AddNameValuePair(k, v)
	}
}

func (event *EventDataImpl) appendNameValuePairs(builder *bytes.Buffer) {
	event.addDefaultNameValuePairs()

	for k, v := range event.nameValues {
		builder.WriteString(k)
		builder.WriteByte('=')
		builder.WriteString(v)
		builder.WriteString(CRLF)
	}
}

func (event *EventDataImpl) RecordProfiledData() {
	var queryLogEnabled bool = false
	var listenersConfigured bool = false

	if event.queryLog != nil && event.queryLog.Level == logrus.InfoLevel {
		queryLogEnabled = true
	}

	if event.listeners != nil && len(event.listeners) != 0 {
		listenersConfigured = true
	}

	if queryLogEnabled || listenersConfigured {
		// finish any TimeAggregators that may not be done
		for _, v := range event.aggregators {
			v.Finish(event.timeSource)
		}

		entry := QueryLogEntryImpl{}
		str := entry.Format(event)

		if listenersConfigured {
			for _, value := range event.listeners {
				value.notify(&entry)
			}
		} else {
			event.queryLog.Print(str)
		}
	}
}

func (event *EventDataImpl) toString() string {
	entry := QueryLogEntryImpl{}
	return entry.Format(event)
}

func (event *EventDataImpl) producesHistory() bool {
	return !event.quietMode
}

func (event *EventDataImpl) getCount(counterName string) int64 {
	count, contains := event.counters[counterName]

	if !contains {
		return -1
	}

	return count
}